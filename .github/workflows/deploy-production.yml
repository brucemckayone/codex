name: Production Deployment

on:
  workflow_run:
    workflows: ['PR and Push CI (Neon ephemeral DB)']
    types:
      - completed
    branches:
      - main

permissions:
  contents: read
  deployments: write
  issues: write # For failure notifications

concurrency:
  group: production-deployment
  cancel-in-progress: false # Never cancel production deploys mid-flight

jobs:
  deploy-production:
    name: Deploy to Production
    runs-on: ubuntu-latest
    # Only deploy if tests passed and this is a push to main
    if: |
      github.event.workflow_run.conclusion == 'success' &&
      github.event.workflow_run.event == 'push' &&
      github.event.workflow_run.head_branch == 'main'
    environment:
      name: production
      url: https://codex.revelations.studio

    steps:
      - uses: actions/checkout@v4

      - uses: actions/setup-node@v4
        with:
          node-version: '20'

      - uses: pnpm/action-setup@v4

      - name: Install dependencies
        run: pnpm install --frozen-lockfile

      # CRITICAL: Verify/Create DNS records for custom domains BEFORE deployment
      - name: Verify production DNS records
        id: verify-dns
        run: |
          echo "üîç Verifying production DNS configuration..."
          chmod +x .github/scripts/manage-production-dns.sh

          # First verify, if missing then create
          if ! .github/scripts/manage-production-dns.sh verify ${{ secrets.CLOUDFLARE_DNS_API_TOKEN }} ${{ secrets.CLOUDFLARE_ZONE_ID }}; then
            echo "‚ö†Ô∏è  Some DNS records missing, creating them..."
            .github/scripts/manage-production-dns.sh create ${{ secrets.CLOUDFLARE_DNS_API_TOKEN }} ${{ secrets.CLOUDFLARE_ZONE_ID }}
          fi

          echo "‚úÖ Production DNS verified"

      # Pre-deployment validation: Build all workers BEFORE touching database
      - name: Validate all workers build successfully
        run: |
          echo "üîç Validating worker builds before database migration..."
          pnpm --filter stripe-webhook-handler build
          pnpm --filter auth build
          pnpm --filter web build
          echo "‚úÖ All workers built successfully"

      # Test migrations on a temporary branch first (dry run)
      - name: Test migrations on temporary Neon branch
        id: test-migration
        run: |
          echo "üß™ Testing migrations on temporary branch..."

          # Create temporary test branch
          TEMP_BRANCH_NAME="migration-test-$(date +%s)"
          echo "Creating temporary branch: $TEMP_BRANCH_NAME"

          # Note: This requires neonctl CLI. Install it if not available:
          # npm install -g neonctl

          # For now, we'll skip this test in CI and rely on ephemeral branch testing
          # TODO: Add neonctl and implement full dry-run testing
          echo "‚ö†Ô∏è Dry-run testing not implemented yet - relying on test workflow validation"
          echo "‚úÖ Proceeding with migration (validated in test workflow)"

      # Apply migrations to production database
      - name: Run production migrations
        id: run-migrations
        run: pnpm --filter @codex/database db:migrate
        env:
          DATABASE_URL: ${{ secrets.NEON_PRODUCTION_URL }}
          DB_METHOD: PRODUCTION

      # Verify migration success
      - name: Verify migrations applied successfully
        if: steps.run-migrations.outcome == 'success'
        run: |
          echo "‚úÖ Migrations completed successfully"
          echo "timestamp=$(date -u +%Y-%m-%dT%H:%M:%SZ)" >> $GITHUB_OUTPUT

      # Deploy stripe-webhook-handler to production
      - name: Deploy stripe-webhook-handler
        id: deploy-stripe
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          workingDirectory: workers/stripe-webhook-handler
          command: deploy --env production
          secrets: |
            DATABASE_URL
            STRIPE_SECRET_KEY
            STRIPE_WEBHOOK_SECRET_PAYMENT
            STRIPE_WEBHOOK_SECRET_SUBSCRIPTION
            STRIPE_WEBHOOK_SECRET_CONNECT
            STRIPE_WEBHOOK_SECRET_CUSTOMER
            STRIPE_WEBHOOK_SECRET_BOOKING
            STRIPE_WEBHOOK_SECRET_DISPUTE
        env:
          DATABASE_URL: ${{ secrets.NEON_PRODUCTION_URL }}
          STRIPE_SECRET_KEY: ${{ secrets.STRIPE_PRODUCTION_KEY }}
          STRIPE_WEBHOOK_SECRET_PAYMENT: ${{ secrets.STRIPE_PRODUCTION_PAYMENT_WEBHOOK_SECRET }}
          STRIPE_WEBHOOK_SECRET_SUBSCRIPTION: ${{ secrets.STRIPE_PRODUCTION_SUBSCRIPTION_WEBHOOK_SECRET }}
          STRIPE_WEBHOOK_SECRET_CONNECT: ${{ secrets.STRIPE_PRODUCTION_CONNECT_WEBHOOK_SECRET }}
          STRIPE_WEBHOOK_SECRET_CUSTOMER: ${{ secrets.STRIPE_PRODUCTION_CUSTOMER_WEBHOOK_SECRET }}
          STRIPE_WEBHOOK_SECRET_BOOKING: ${{ secrets.STRIPE_PRODUCTION_BOOKING_WEBHOOK_SECRET }}
          STRIPE_WEBHOOK_SECRET_DISPUTE: ${{ secrets.STRIPE_PRODUCTION_DISPUTE_WEBHOOK_SECRET }}

      # Verify API worker is healthy after deployment
      - name: Health check - API worker
        timeout-minutes: 5
        run: |
          echo "üè• Checking API worker health at https://api.revelations.studio..."

          # Wait for custom domain SSL to provision (can take 30-90 seconds)
          echo "‚è≥ Waiting for SSL certificate provisioning..."
          sleep 30

          # Retry health check with exponential backoff
          MAX_RETRIES=10
          RETRY_COUNT=0
          RETRY_DELAY=5

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://api.revelations.studio/health || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ API worker is healthy (HTTP $HTTP_CODE)"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "‚è≥ Connection failed (SSL provisioning?), retrying in ${RETRY_DELAY}s... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            else
              echo "‚è≥ API returned HTTP $HTTP_CODE, retrying in ${RETRY_DELAY}s... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            fi

            sleep $RETRY_DELAY
            RETRY_COUNT=$((RETRY_COUNT + 1))
            RETRY_DELAY=$((RETRY_DELAY * 2)) # Exponential backoff
          done

          echo "‚ùå API worker health check failed after $MAX_RETRIES attempts"
          echo "Last HTTP code: $HTTP_CODE"
          exit 1

      # Deploy auth-worker to production
      - name: Deploy auth-worker
        id: deploy-auth
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          workingDirectory: workers/auth
          command: deploy --env production
          secrets: |
            DATABASE_URL
            SESSION_SECRET
            SESSION_SECRET_PRODUCTION
            BETTER_AUTH_SECRET
        env:
          DATABASE_URL: ${{ secrets.NEON_PRODUCTION_URL }}
          SESSION_SECRET: ${{ secrets.SESSION_SECRET_PRODUCTION }}
          SESSION_SECRET_PRODUCTION: ${{ secrets.SESSION_SECRET_PRODUCTION }}
          BETTER_AUTH_SECRET: ${{ secrets.BETTER_AUTH_SECRET_PRODUCTION }}

      # Verify auth worker is healthy after deployment
      - name: Health check - Auth worker
        timeout-minutes: 5
        run: |
          echo "üè• Checking Auth worker health at https://auth.revelations.studio..."

          # Wait for custom domain SSL (shorter wait since API already provisioned)
          echo "‚è≥ Waiting for SSL certificate..."
          sleep 15

          MAX_RETRIES=10
          RETRY_COUNT=0
          RETRY_DELAY=5

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://auth.revelations.studio/health || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Auth worker is healthy (HTTP $HTTP_CODE)"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "‚è≥ Connection failed (SSL provisioning?), retrying in ${RETRY_DELAY}s... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            else
              echo "‚è≥ Auth returned HTTP $HTTP_CODE, retrying in ${RETRY_DELAY}s... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            fi

            sleep $RETRY_DELAY
            RETRY_COUNT=$((RETRY_COUNT + 1))
            RETRY_DELAY=$((RETRY_DELAY * 2))
          done

          echo "‚ùå Auth worker health check failed after $MAX_RETRIES attempts"
          echo "Last HTTP code: $HTTP_CODE"
          exit 1

      # Build SvelteKit app (NOTE: Build was already validated earlier)
      - name: Build SvelteKit app for production
        run: pnpm --filter web build
        env:
          DATABASE_URL: ${{ secrets.NEON_PRODUCTION_URL }}
          PUBLIC_APP_URL: https://codex.revelations.studio

      # Deploy SvelteKit to production
      - name: Deploy SvelteKit to production
        id: deploy-web
        uses: cloudflare/wrangler-action@v3
        with:
          apiToken: ${{ secrets.CLOUDFLARE_API_TOKEN }}
          accountId: ${{ secrets.CLOUDFLARE_ACCOUNT_ID }}
          workingDirectory: apps/web
          command: deploy --env production
          secrets: |
            DATABASE_URL
        env:
          DATABASE_URL: ${{ secrets.NEON_PRODUCTION_URL }}

      # Verify web app is healthy after deployment
      - name: Health check - Web app
        timeout-minutes: 5
        run: |
          echo "üè• Checking Web app health at https://codex.revelations.studio..."

          # Wait for custom domain SSL
          echo "‚è≥ Waiting for SSL certificate..."
          sleep 15

          MAX_RETRIES=10
          RETRY_COUNT=0
          RETRY_DELAY=5

          while [ $RETRY_COUNT -lt $MAX_RETRIES ]; do
            # For SvelteKit app, check the homepage (may not have /health endpoint)
            HTTP_CODE=$(curl -s -o /dev/null -w "%{http_code}" https://codex.revelations.studio || echo "000")

            if [ "$HTTP_CODE" = "200" ]; then
              echo "‚úÖ Web app is healthy (HTTP $HTTP_CODE)"
              exit 0
            elif [ "$HTTP_CODE" = "000" ]; then
              echo "‚è≥ Connection failed (SSL provisioning?), retrying in ${RETRY_DELAY}s... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            else
              echo "‚è≥ Web app returned HTTP $HTTP_CODE, retrying in ${RETRY_DELAY}s... (attempt $((RETRY_COUNT + 1))/$MAX_RETRIES)"
            fi

            sleep $RETRY_DELAY
            RETRY_COUNT=$((RETRY_COUNT + 1))
            RETRY_DELAY=$((RETRY_DELAY * 2))
          done

          echo "‚ùå Web app health check failed after $MAX_RETRIES attempts"
          echo "Last HTTP code: $HTTP_CODE"
          exit 1

      - name: Deployment notification
        if: success()
        run: |
          echo "‚úÖ Production deployment successful"
          echo "üåê Web App: https://codex.revelations.studio - Health: OK"
          echo "üîå API: https://api.revelations.studio - Health: OK"
          echo "üîê Auth: https://auth.revelations.studio - Health: OK"
          echo "üíæ Database: Migrations applied successfully"
          echo "‚ö° All workers deployed and verified healthy"

      - name: Rollback instructions on failure
        if: failure()
        uses: actions/github-script@v7
        with:
          script: |
            const issue = await github.rest.issues.create({
              owner: context.repo.owner,
              repo: context.repo.repo,
              title: `üö® Production Deployment Failed - ${context.sha.substring(0, 7)}`,
              labels: ['production', 'deployment-failure', 'urgent'],
              body: `## Production Deployment Failed

            **Commit**: ${context.sha}
            **Workflow Run**: ${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId}
            **Timestamp**: ${new Date().toISOString()}

            ### Immediate Actions Required

            #### 1. Check which step failed
            [View workflow logs](${context.serverUrl}/${context.repo.owner}/${context.repo.repo}/actions/runs/${context.runId})

            #### 2. If migrations failed
            - Database is still on old schema ‚úÖ
            - Workers are still on old version ‚úÖ
            - **No rollback needed** - safe to retry after fixing migrations

            #### 3. If worker deployment failed AFTER migrations
            ‚ö†Ô∏è **CRITICAL**: Database has new schema, but workers expect old schema

            **Manual rollback required**:

            \`\`\`bash
            # Option A: Rollback worker to previous version
            wrangler rollback --name stripe-webhook-handler-production
            wrangler rollback --name auth-worker-production
            wrangler rollback --name codex-web-production

            # Option B: Restore database from Neon point-in-time
            # Create restore branch from 30 minutes ago
            neonctl branches create \\
              --name emergency-restore-$(date +%s) \\
              --parent production \\
              --timestamp "30 minutes ago"

            # Then redeploy workers pointing to restored branch
            \`\`\`

            #### 4. If health checks failed
            - Workers deployed successfully but not responding
            - Check Cloudflare dashboard for errors
            - Verify DNS is resolving correctly
            - Check worker logs: \`wrangler tail <worker-name>\`

            ### Prevention
            - This workflow now validates builds BEFORE running migrations
            - Health checks verify each worker after deployment
            - Consider adding staged rollout or blue-green deployment

            @${context.actor} please investigate and respond here once resolved.
            `
            });

            console.log('Created issue:', issue.data.html_url);
