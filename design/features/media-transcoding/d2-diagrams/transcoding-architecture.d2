# Media Transcoding Architecture - Phase 1
# Import theme variables
...@../../../d2/theme

direction: down

# Content Management Trigger
content_mgmt: {
  label: "Content Management"

  upload_confirm: {
    label: "Upload Confirmed\n\nPOST /api/media/confirm\nVideo uploaded to B2"
    style: {
      fill: ${color-nextjs-sub}
      stroke: ${stroke-nextjs-sub}
    }
  }

  style: {
    fill: ${color-nextjs}
    stroke: ${stroke-nextjs}
    stroke-width: 2
  }
}

# Worker Layer
worker: {
  label: "media-api Worker"

  internal_trigger: {
    label: "Internal Trigger\n\nPOST /internal/media/:id/transcode\nCalls Runpod API"
    style: {
      fill: ${color-worker}
      stroke: ${stroke-worker}
    }
  }

  webhook_handler: {
    label: "Webhook Handler\n\nPOST /api/transcoding/webhook\nProcesses completion events"
    style: {
      fill: ${color-worker}
      stroke: ${stroke-worker}
    }
  }

  style: {
    fill: ${color-worker}
    stroke: ${stroke-worker}
    stroke-width: 2
  }
}

# Runpod GPU Processing
runpod: {
  label: "Runpod Serverless GPU"

  endpoint: {
    label: "Custom Docker Image\n\n1. Create mezzanine\n2. Measure loudness\n3. Transcode to HLS\n4. Generate assets\n\nGPU-accelerated processing"
    style: {
      fill: "#E1BEE7"
      stroke: "#BA68C8"
    }
  }

  style: {
    fill: "#F3E5F5"
    stroke: "#BA68C8"
    stroke-width: 2
  }
}

# Backblaze B2 Archival Storage
b2: {
  label: "Backblaze B2 (Archival)"

  original_bucket: {
    label: "Original Files\n\ncodex-archive\n\noriginals/{creatorId}/{mediaId}/\noriginal.*\n\n(Temporary - deleted after\nmezzanine verified)"
    style: {
      fill: "#FFF3E0"
      stroke: "#FFB74D"
    }
  }

  mezzanine_bucket: {
    label: "Mezzanine Files\n\ncodex-archive\n\nmezzanine/{creatorId}/{mediaId}/\nmezzanine.mp4\n\n(Permanent - for re-encoding)"
    style: {
      fill: "#FFF3E0"
      stroke: "#FFB74D"
    }
  }

  style: {
    fill: "#FFF8E1"
    stroke: "#FFB74D"
    stroke-width: 2
  }
}

# Cloudflare R2 Delivery Storage
r2: {
  label: "Cloudflare R2 (Delivery)"

  output_bucket: {
    label: "Transcoded Output\n\ncodex-media-{env}\n\nâ€¢ {creatorId}/hls/{mediaId}/\nâ€¢ {creatorId}/hls-audio/{mediaId}/\nâ€¢ Preview clips"
    style: {
      fill: ${color-r2}
      stroke: ${stroke-r2}
    }
  }

  assets_bucket: {
    label: "Assets\n\ncodex-assets-{env}\n\nâ€¢ Thumbnails\nâ€¢ Waveform JSON/PNG"
    style: {
      fill: ${color-r2}
      stroke: ${stroke-r2}
    }
  }

  style: {
    fill: ${color-r2}
    stroke: ${stroke-r2}
    stroke-width: 2
  }
}

# Database Layer
postgres: {
  label: "Neon PostgreSQL"
  shape: cylinder

  tables: {
    label: "Database Tables\n\nâ€¢ media_items\n  status: uploaded/transcoding/\n  ready/failed\n  mezzanineKey, mezzanineStatus\n  readyVariants, loudness*\n  runpodJobId, transcodingError"
    style: {
      fill: ${color-postgres}
      stroke: ${stroke-postgres}
    }
  }

  style: {
    fill: "#E8EAF6"
    stroke: "#9FA8DA"
    stroke-width: 2
  }
}

# Flow Step 1: Upload complete, trigger job
content_mgmt.upload_confirm -> worker.internal_trigger: "1. Trigger transcoding\nPOST /internal/media/:id/transcode" {
  style.stroke: ${arrow-cache}
  style.stroke-width: 2
}

content_mgmt.upload_confirm -> postgres.tables: "UPDATE media_items\nSET status='uploaded'" {
  style.stroke: ${arrow-sql}
}

# Flow Step 2: Call Runpod API
worker.internal_trigger -> runpod.endpoint: "2. POST /run\n{inputKey, outputPrefix,\n mediaType: video/audio}" {
  style.stroke: ${arrow-external}
  style.stroke-width: 3
}

runpod.endpoint -> worker.internal_trigger: "Return {jobId}" {
  style.stroke: ${arrow-external}
  style.stroke-dash: 3
}

worker.internal_trigger -> postgres.tables: "UPDATE media_items\nSET status='transcoding',\nrunpodJobId=jobId" {
  style.stroke: ${arrow-sql}
}

# Flow Step 3: Runpod downloads from B2
runpod.endpoint -> b2.original_bucket: "3. Download original\n(via S3-compatible API)" {
  style.stroke: ${arrow-external}
  style.stroke-width: 2
}

# Flow Step 4: Runpod creates mezzanine
runpod.endpoint -> runpod.endpoint: "4. Create mezzanine\n(H.264 CRF 18)\nMeasure loudness" {
  style.stroke: "#BA68C8"
  style.stroke-dash: 3
}

runpod.endpoint -> b2.mezzanine_bucket: "5. Upload mezzanine\n(via Bandwidth Alliance)" {
  style.stroke: "#FFB74D"
  style.stroke-width: 2
}

# Flow Step 5: Runpod generates HLS
runpod.endpoint -> runpod.endpoint: "6. Transcode:\nVideo â†’ HLS variants\nAudio â†’ HLS + waveform" {
  style.stroke: "#BA68C8"
  style.stroke-dash: 3
}

runpod.endpoint -> r2.output_bucket: "7. Upload HLS outputs\n(playlists, segments)" {
  style.stroke: ${arrow-external}
  style.stroke-width: 2
}

runpod.endpoint -> r2.assets_bucket: "Upload assets\n(thumbnails, waveforms)" {
  style.stroke: ${arrow-external}
}

# Flow Step 6: Runpod sends webhook
runpod.endpoint -> worker.webhook_handler: "8. POST /api/transcoding/webhook\n{status, mezzanineKey,\nreadyVariants, loudness}" {
  style.stroke: ${arrow-external}
  style.stroke-width: 2
}

worker.webhook_handler -> postgres.tables: "UPDATE media_items\nSET status='ready',\nmezzanineKey, readyVariants,\nloudness*, hlsKeys" {
  style.stroke: ${arrow-sql}
  style.stroke-width: 2
}

# Original deletion (deferred)
b2.original_bucket -> b2.original_bucket: "Delete original\n(24h after mezzanine verified)" {
  style.stroke: "#FF5722"
  style.stroke-dash: 5
}

# Error flow
worker.webhook_handler -> postgres.tables: "If failed:\nSET status='failed'\nUpdate transcodingError\nIncrement attempts" {
  style.stroke: ${arrow-sql}
  style.stroke-dash: 3
}

# Notes
note_tiered: {
  label: "ðŸ’° Tiered Storage Strategy:\n\nB2 (Archival): ~$6/TB\nâ€¢ Original files (temporary)\nâ€¢ Mezzanine files (permanent)\nâ€¢ Bandwidth Alliance: Free egress to CF\n\nR2 (Delivery): ~$15/TB\nâ€¢ HLS playlists & segments\nâ€¢ Zero egress to CF Workers"
  shape: text
}

note_mezzanine: {
  label: "ðŸŽ¬ Mezzanine Pipeline:\n1. Download original from B2\n2. Create high-quality H.264 CRF 18\n3. Measure loudness (two-pass EBU R128)\n4. Upload mezzanine to B2\n5. Transcode HLS from mezzanine\n6. Delete original after 24h"
  shape: text
}

note_outputs: {
  label: "ðŸ“¹ Transcoding Outputs:\n\nVideo:\nâ€¢ HLS master + variants (1080pâ†’360p)\nâ€¢ 30-sec preview clip\nâ€¢ Auto-generated thumbnail\nâ€¢ readyVariants: ['1080p','720p'...]\n\nAudio:\nâ€¢ HLS variants (128k, 64k)\nâ€¢ Waveform JSON + PNG\nâ€¢ Loudness measurements"
  shape: text
}
