# P1-CONTENT-001: Content Management Service

**Priority**: P0 (Critical - foundation for other features)
**Status**: âœ… COMPLETE
**Estimated Effort**: 5 days (Actual: 5 days)

---

## Table of Contents

- [Overview](#overview)
- [System Context](#system-context)
- [Database Schema](#database-schema)
- [Service Architecture](#service-architecture)
- [API Integration](#api-integration)
- [Available Patterns & Utilities](#available-patterns--utilities)
- [Dependencies](#dependencies)
- [Implementation Checklist](#implementation-checklist)
- [Testing Strategy](#testing-strategy)
- [Notes](#notes)

---

## Overview

Content Management is the core domain service enabling creators to publish video and audio content to the Codex platform. It manages the complete content lifecycle from draft creation through publication, media asset tracking, and soft deletion.

This service sits at the heart of the platform, coordinating between media storage (R2), transcoding pipelines, and access control. Creators upload media files (videos/audio) which are transcoded and stored as reusable media items. These media items are then packaged into publishable content with metadata, pricing, and visibility controls.

The content model separates media assets from content metadata, enabling a media library pattern where one upload can be referenced by multiple content pieces. Content can belong to an organization or a creator's personal profile, supporting multi-tenant isolation.

Key capabilities:
- **Content CRUD**: Create, read, update, and soft-delete content with rich metadata
- **Media Library**: Reusable media items tracked separately from content
- **Publishing Workflow**: Draft â†’ Published â†’ Archived lifecycle with timestamps
- **Pricing & Access**: Set content pricing (free or paid) and visibility rules
- **Multi-tenant**: Content scoped to creator and optionally to organization
- **Soft Deletes**: Content is never hard-deleted, preserving purchase history

This service is consumed by:
- **Creators** via Content API endpoints for managing their content library
- **Access Control Service** (P1-ACCESS-001) for verifying publication status before streaming
- **Checkout Service** (P1-ECOM-001) for retrieving pricing and creator information
- **Admin Dashboard** (P1-ADMIN-001) for platform-wide content analytics

---

## System Context

### Upstream Dependencies

**Auth Service** (âœ… Available):
- Provides authenticated user context (user ID, organization ID, role)
- Session validation for all API requests
- Creator role verification for content management operations

**Media Transcoding Service** (P1-TRANSCODE-001):
- Populates `media_items` table with transcoded media
- Content service validates media exists and is ready before publication
- Media must be owned by creator and have `status = 'ready'`

**R2 Storage** (âœ… Available via `@codex/cloudflare-clients`):
- Stores original media files and transcoded HLS outputs
- Content service reads R2 keys from media_items table
- Presigned URLs generated by access service (not content service)

**PostgreSQL Database** (âœ… Available via `@codex/database`):
- Neon serverless Postgres for all content and media metadata
- Supports transactions for ACID compliance
- Soft delete pattern via `deletedAt` timestamp

### Downstream Consumers

**Access Control Service** (P1-ACCESS-001):
- Queries `content` table to verify publication status
- Checks visibility and pricing to enforce access rules
- Generates streaming URLs for published content
- Integration: Reads published content where `status = 'published'` AND `deletedAt IS NULL`

**Checkout Service** (P1-ECOM-001):
- Queries `content` table for pricing information
- Retrieves creator ID for revenue routing
- Validates content is purchasable (price > 0)
- Integration: Reads content pricing and metadata for Stripe session creation

**Admin Dashboard** (P1-ADMIN-001):
- Queries `content` and `media_items` for platform analytics
- Views all content across all creators (no creator scoping)
- Monitors content creation metrics
- Integration: Read-only queries without creator filtering

### External Services

**Cloudflare R2**: Object storage for media files
**Neon PostgreSQL**: Serverless Postgres for metadata
**Clerk Auth**: User authentication and session management

### Integration Flow

```
Creator Request
    â†“
Auth Middleware (session validation)
    â†“
Content API (route-level security)
    â†“
ContentService (business logic, creator scoping)
    â†“
Database (content + media_items tables)
    â†“
Response (standardized format)
```

---

## Database Schema

### Tables

#### `media_items`

**Purpose**: Tracks uploaded and transcoded media assets (video/audio) separate from content. Enables media library pattern where one media item can be referenced by multiple content pieces.

**Key Fields**:
- `id` (text, PK): Unique media item identifier
- `creatorId` (text, FK â†’ users.id): Media owner (scoping)
- `title`, `description`: Media metadata
- `mediaType`: 'video' | 'audio'
- `status`: 'uploading' | 'uploaded' | 'transcoding' | 'ready' | 'failed'
- `r2Key`: Path in R2 storage (e.g., "originals/{media_id}/video.mp4")
- `hlsMasterPlaylistKey`: HLS master playlist after transcoding
- `thumbnailKey`: Thumbnail image key in R2
- `durationSeconds`, `width`, `height`: Media metadata
- `createdAt`, `updatedAt`, `deletedAt`: Timestamps (soft delete pattern)

**Constraints**:
- Primary Key: `id`
- Foreign Key: `creatorId` â†’ `users.id` (creator must exist)
- Check: `status` IN ('uploading', 'uploaded', 'transcoding', 'ready', 'failed')
- Check: `mediaType` IN ('video', 'audio')

**Indexes**:
- `idx_media_items_creator_id` ON `creatorId`: Creator-scoped queries
- `idx_media_items_status` ON `creatorId, status`: Filter by transcoding status
- `idx_media_items_type` ON `creatorId, mediaType`: Filter by media type

---

#### `content`

**Purpose**: Publishable content records that reference media items. Contains metadata, pricing, visibility, and publication state.

**Key Fields**:
- `id` (text, PK): Unique content identifier
- `creatorId` (text, FK â†’ users.id): Content owner (scoping)
- `organizationId` (text, FK â†’ organizations.id, nullable): Organization or personal content (NULL = personal)
- `mediaItemId` (text, FK â†’ media_items.id): Referenced media asset
- `title`, `slug`, `description`: Content metadata
- `contentType`: 'video' | 'audio' | 'written' (Phase 1: video, audio only)
- `category`: Simple string category (Phase 1, no normalization)
- `tags`: JSONB array of tag strings (Phase 1, no normalization)
- `visibility`: 'public' | 'private' | 'members_only' | 'purchased_only'
- `priceCents`: Integer cents (NULL = free, e.g., 999 = $9.99)
- `status`: 'draft' | 'published' | 'archived'
- `publishedAt`: Timestamp when published (NULL if draft)
- `viewCount`, `purchaseCount`: Usage metrics
- `createdAt`, `updatedAt`, `deletedAt`: Timestamps

**Constraints**:
- Primary Key: `id`
- Foreign Keys:
  - `creatorId` â†’ `users.id`
  - `organizationId` â†’ `organizations.id` (nullable)
  - `mediaItemId` â†’ `media_items.id` (nullable, future: written content)
- Unique: `(slug, organizationId)` - slug unique per organization
- Check: `contentType` IN ('video', 'audio', 'written')
- Check: `visibility` IN ('public', 'private', 'members_only', 'purchased_only')
- Check: `status` IN ('draft', 'published', 'archived')

**Indexes**:
- `idx_content_creator_id` ON `creatorId`: Creator-scoped queries
- `idx_content_organization_id` ON `organizationId`: Organization filtering
- `idx_content_media_item_id` ON `mediaItemId`: Media lookup
- `idx_content_slug` ON `slug, organizationId`: Slug-based URLs
- `idx_content_status` ON `status`: Draft/published filtering
- `idx_content_published_at` ON `publishedAt`: Recent content queries
- `idx_content_category` ON `category`: Category filtering

### Relationships

```
users (1) â”€â”€â”€â”€â”€< media_items (N)
  â””â”€ creatorId

users (1) â”€â”€â”€â”€â”€< content (N)
  â””â”€ creatorId

organizations (1) â”€â”€â”€â”€â”€< content (N)
  â””â”€ organizationId (nullable)

media_items (1) â”€â”€â”€â”€â”€< content (N)
  â””â”€ mediaItemId
```

### Migration Considerations

**Manual Steps Required**:
- CHECK constraints must be added manually to migration SQL (Drizzle doesn't auto-generate)
- Verify slug uniqueness constraint includes organization_id
- Add indexes for foreign keys (creator_id, organization_id, media_item_id)

**Database Constraints Alignment**:
- Validation enums (Zod schemas) MUST match database CHECK constraints exactly
- Any enum changes require schema migration + validation schema update

**Soft Delete Pattern**:
- All queries MUST filter `deletedAt IS NULL` to exclude deleted records
- Use query helper: `scopedNotDeleted(table, userId)`

---

## Service Architecture

### Service Responsibilities

**ContentService** (extends `BaseService` from `@codex/service-errors`):
- **Primary Responsibility**: Manage content lifecycle and metadata for creator-owned content
- **Key Operations**:
  - `create()`: Create draft content, validate media ownership and readiness
  - `get()`: Retrieve content by ID with creator scoping
  - `update()`: Update content metadata (title, description, pricing, etc.)
  - `publish()`: Transition draft â†’ published, set publishedAt timestamp
  - `unpublish()`: Transition published â†’ draft
  - `delete()`: Soft delete (set deletedAt timestamp)
  - `list()`: Query content with filters (status, category, type), creator-scoped, paginated

**MediaItemService** (extends `BaseService` from `@codex/service-errors`):
- **Primary Responsibility**: Track uploaded media and transcoding status
- **Key Operations**:
  - `create()`: Create media record after upload initiation
  - `get()`: Retrieve media item by ID
  - `update()`: Update media metadata
  - `updateStatus()`: Transition media through transcoding workflow
  - `markAsReady()`: Set status = 'ready' with HLS keys after transcoding
  - `delete()`: Soft delete media item
  - `list()`: Query media library with filters

### Key Business Rules

1. **Media Ownership Validation**:
   - Content can only reference media owned by the same creator
   - Enforced by querying: `eq(mediaItems.creatorId, creatorId)` before content creation
   - Prevents creators from using others' media assets

2. **Media Readiness**:
   - Content cannot be published until media status = 'ready'
   - Enforced by checking `mediaItem.status === 'ready'` before publish
   - Ensures playback works before content goes live

3. **Content Type Matching**:
   - Video content (`contentType = 'video'`) must reference video media (`mediaType = 'video'`)
   - Audio content must reference audio media
   - Enforced by type comparison before creation

4. **Organization vs Personal Content**:
   - Content with `organizationId` belongs to organization
   - Content with `organizationId = NULL` is personal
   - Creator can have both org and personal content
   - Queries filter by `organizationId` when listing org content

5. **Slug Uniqueness**:
   - Slug must be unique per organization (database constraint)
   - Used for SEO-friendly URLs (e.g., `/content/{org-slug}/{content-slug}`)
   - Enforced by unique constraint on `(slug, organizationId)`

6. **Soft Delete Pattern**:
   - Content is never hard-deleted from database
   - `deletedAt` timestamp marks deletion
   - All queries filter `deletedAt IS NULL`
   - Preserves purchase history and analytics

### Error Handling Approach

**Custom Error Classes** (extend base errors from `@codex/service-errors`):
- `ContentNotFoundError`: Thrown when content ID doesn't exist or isn't owned by creator â†’ HTTP 404
- `MediaNotFoundError`: Thrown when referenced media doesn't exist or isn't owned by creator â†’ HTTP 404
- `MediaNotReadyError`: Thrown when trying to publish content with media status != 'ready' â†’ HTTP 400
- `ContentTypeMismatchError`: Thrown when content type doesn't match media type â†’ HTTP 400
- `SlugConflictError`: Thrown when slug already exists for organization â†’ HTTP 409

**Error Propagation**:
- Service throws specific error classes
- Worker layer catches via `mapErrorToResponse()` from `@codex/service-errors`
- Errors converted to standardized HTTP responses with error codes

**Error Recovery**:
- No automatic retries (operations are idempotent where possible)
- Transaction rollback on failure ensures data consistency

### Transaction Boundaries

**Operations requiring `db.transaction()`**:
- `create()`: Multi-step operation (media validation + content insert) must be atomic
- `publish()`: Updates content status + publishedAt in single transaction
- Multi-content operations (future): Bulk publish/unpublish

**Single-operation methods** (no transaction needed):
- `get()`: Read-only query
- `update()`: Single UPDATE statement
- `delete()`: Single UPDATE statement (sets deletedAt)
- `list()`: Read-only query

---

## API Integration

### Endpoints

| Method | Path | Purpose | Security Policy |
|--------|------|---------|-----------------|
| POST | `/api/content` | Create draft content | `POLICY_PRESETS.creator()` |
| GET | `/api/content/:id` | Retrieve content by ID | `POLICY_PRESETS.authenticated()` |
| PATCH | `/api/content/:id` | Update content metadata | `POLICY_PRESETS.creator()` |
| GET | `/api/content` | List content with filters | `POLICY_PRESETS.authenticated()` |
| POST | `/api/content/:id/publish` | Publish content | `POLICY_PRESETS.creator()` |
| POST | `/api/content/:id/unpublish` | Unpublish content | `POLICY_PRESETS.creator()` |
| DELETE | `/api/content/:id` | Soft delete content | `POLICY_PRESETS.creator()` with stricter rate limit |

| Method | Path | Purpose | Security Policy |
|--------|------|---------|-----------------|
| POST | `/api/media` | Create media item record | `POLICY_PRESETS.creator()` |
| GET | `/api/media/:id` | Retrieve media item | `POLICY_PRESETS.authenticated()` |
| PATCH | `/api/media/:id` | Update media metadata | `POLICY_PRESETS.creator()` |
| GET | `/api/media` | List media library | `POLICY_PRESETS.authenticated()` |

### Standard Pattern

All endpoints follow the `@codex/worker-utils` pattern:

```typescript
app.post('/api/content',
  withPolicy(POLICY_PRESETS.creator()), // Route-level security
  createAuthenticatedHandler({
    inputSchema: createContentSchema, // Zod validation from @codex/validation
    handler: async ({ input, context }) => {
      const service = new ContentService(context);
      const result = await service.create(input, context.user.id);
      return { data: result }; // StandardResponse wrapper
    }
  })
);
```

### Security Policies

**Route-Level Security** (via `withPolicy()` from `@codex/worker-utils`):
- `POLICY_PRESETS.authenticated()`: Any authenticated user (read operations)
- `POLICY_PRESETS.creator()`: Creator/admin only (write operations)
- Custom rate limits per endpoint (creation slower than reads)

**Creator Scoping**:
- All service methods accept `creatorId` parameter
- Service filters all queries by `eq(content.creatorId, creatorId)`
- Creators can only CRUD their own content

**Organization Scoping**:
- Optional `organizationId` parameter for org content
- NULL organizationId = personal content
- Creator can have both org and personal content

### Response Format

All endpoints return standardized responses from `@codex/shared-types`:

**Success (single item)**:
```typescript
{ data: Content }
```

**Success (paginated list)**:
```typescript
{
  data: Content[],
  pagination: {
    page: number,
    pageSize: number,
    totalCount: number,
    totalPages: number
  }
}
```

**Error**:
```typescript
{
  error: {
    message: string,
    code: string, // 'CONTENT_NOT_FOUND', 'MEDIA_NOT_READY', etc.
    details?: Record<string, any>
  }
}
```

---

## Available Patterns & Utilities

### Foundation Packages

#### `@codex/database`

**Query Helpers**:
- `scopedNotDeleted(table, userId)`: Combines creator scoping + soft delete filtering in one helper
  - Example: `scopedNotDeleted(content, creatorId)` â†’ `eq(content.creatorId, creatorId) AND isNull(content.deletedAt)`
- `withPagination(query, page, pageSize)`: Standardized pagination with offset/limit
- `creatorScope(table, userId)`: Filter by creator ownership
- `orgScope(table, organizationId)`: Filter by organization (nullable)

**Transaction Support**:
- `db.transaction(async (tx) => { ... })`: Atomic multi-step operations
  - Use for operations that must succeed or fail together
  - Automatic rollback on error

**Error Detection**:
- `isUniqueViolation(error)`: Check for unique constraint violations (e.g., slug conflict)
- `isForeignKeyViolation(error)`: Check for foreign key violations

**When to use**: All service implementations use these for data access. Every query should use `scopedNotDeleted()` to ensure creator scoping and soft delete filtering.

---

#### `@codex/service-errors`

**BaseService** (extend this for all service classes):
- Provides: `this.db`, `this.userId`, `this.environment` from config
- Constructor signature: `constructor(config: ServiceConfig)`
- Error handling: Throw specific error classes, let worker map to HTTP

**Error Classes**:
- `NotFoundError(message)`: Entity not found â†’ HTTP 404
- `ValidationError(message, details?)`: Invalid input â†’ HTTP 400
- `ConflictError(message)`: Duplicate/constraint violation â†’ HTTP 409
- `ForbiddenError(message)`: Insufficient permissions â†’ HTTP 403
- `InternalServiceError(message)`: Unexpected error â†’ HTTP 500

**Error Mapping**:
- `mapErrorToResponse(error)`: Converts service errors to standardized HTTP responses
  - Called in worker error handler
  - Returns `{ error: { message, code, details } }`

**When to use**: Every service extends BaseService. Throw specific errors for domain problems. Worker catches with mapErrorToResponse().

---

#### `@codex/validation`

**Schema Pattern**:
- Define Zod schemas for all API inputs and service parameters
- Type inference: `type CreateContentInput = z.infer<typeof createContentSchema>`
- Validation happens automatically in `createAuthenticatedHandler()`

**Content Schemas** (from `@codex/validation/content-schemas`):
- `createContentSchema`: Create content validation
- `updateContentSchema`: Update content validation (partial)
- `contentQuerySchema`: List/filter content validation
- `createMediaItemSchema`: Create media item validation

**Security**:
- All schemas prevent XSS (sanitizedString helper)
- Path traversal prevention (file path validation)
- Enums align with database CHECK constraints

**When to use**: Define schemas for all API inputs. Never validate in service layer - schemas are the source of truth for validation.

---

#### `@codex/security`

**Middleware** (applied via `@codex/worker-utils`):
- `securityHeaders()`: CSP, X-Frame-Options, HSTS
- `rateLimit(preset)`: KV-backed rate limiting
  - Presets: 'api', 'auth', 'strict', 'streaming'
- `requireAuth()`, `optionalAuth()`: Session validation (if needed for global auth)

**Worker Auth**:
- `workerAuth()`: HMAC-based worker-to-worker authentication (not used in this service)

**When to use**: Applied in worker setup via `createWorker()`. Security headers and rate limiting are automatic.

---

### Utility Packages

#### `@codex/worker-utils`

**Worker Setup**:
- `createWorker(config)`: Fully configured Hono app with all middleware
  - Security headers, CORS, logging, error handling, request tracking
  - Returns configured Hono app instance

**Route Handlers**:
- `createAuthenticatedHandler({ inputSchema, handler })`: Unified handler for authenticated routes
  - Validates input with Zod schema
  - Provides authenticated context with user info
  - Catches errors and maps to HTTP responses
- `createAuthenticatedGetHandler({ schema, handler })`: Same but for GET requests with query params

**Security Policies** (via `withPolicy()`):
- `withPolicy(policy)`: Apply route-level authorization
- `POLICY_PRESETS.authenticated()`: Requires valid session
- `POLICY_PRESETS.creator()`: Requires creator or admin role
- `POLICY_PRESETS.platformOwner()`: Requires admin role only

**When to use**: Every worker uses `createWorker()` for setup. Every protected route uses `withPolicy()` for authorization. Use `createAuthenticatedHandler()` for standardized request handling.

---

#### `@codex/cloudflare-clients`

**R2 Storage** (via `R2Service`):
- `R2Service.put(bucket, key, data)`: Upload file to R2
- `R2Service.get(bucket, key)`: Download file from R2
- `R2Service.delete(bucket, key)`: Delete file from R2
- `R2Service.generateSignedUrl(bucket, key, expiresIn)`: Time-limited streaming URLs
  - Used by access service, not content service

**Retry Logic**:
- Automatic exponential backoff on R2 failures

**When to use**: Content service reads R2 keys from `media_items` table but doesn't interact with R2 directly. Access service generates signed URLs for streaming.

---

#### `@codex/observability`

**Logging** (via `ObservabilityClient`):
- `client.info(message, metadata)`: Info-level logs
- `client.warn(message, metadata)`: Warning logs
- `client.error(message, error)`: Error logs with stack traces
- `client.trackError(error, context)`: Error tracking with context

**Structured Logging**:
- All logs include request context (requestId, userId, etc.)
- No PII in logs (only IDs, never emails or names)

**When to use**: All services and workers for monitoring and debugging. Log all operations with IDs only.

---

#### `@codex/test-utils`

**Database Testing**:
- `setupTestDatabase()`: Initialize test database connection
- `teardownTestDatabase()`: Clean up after tests
- `withNeonTestBranch()`: Ephemeral test branches per test file (CI only)

**Test Fixtures**:
- `seedTestUsers()`: Create test user data
- `createTestContent()`, `createTestMedia()`: Create test content/media

**When to use**: All integration tests that need database access.

---

## Dependencies

### Required (Blocking)

| Dependency | Status | Description |
|------------|--------|-------------|
| Auth Service | âœ… Available | Session validation, user context (user ID, role, org ID) |
| Database Schema | âœ… Available | PostgreSQL with content and media_items tables |
| R2 Storage | âœ… Available | Media file storage (@codex/cloudflare-clients) |
| Validation Schemas | âœ… Available | Zod schemas in @codex/validation |

### Optional (Nice to Have)

| Dependency | Status | Description |
|------------|--------|-------------|
| Media Transcoding (P1-TRANSCODE-001) | ðŸš§ Future | Populates media_items with transcoded media. Content service validates media exists but doesn't require transcoding to be complete for draft content. |

### Infrastructure Ready

- âœ… Database schema tooling (Drizzle ORM)
- âœ… Worker deployment pipeline (Cloudflare Workers)
- âœ… R2 Storage access
- âœ… Session management (KV-backed)
- âœ… Rate limiting (KV-backed)
- âœ… Error handling (@codex/service-errors)
- âœ… Observability (logging, metrics)

---

## Implementation Checklist

- [x] **Database Setup**
  - [x] Create schema definitions in `packages/database/src/schema/content.ts`
  - [x] Generate migration with CHECK constraints
  - [x] Add indexes for foreign keys and frequent queries
  - [x] Run migration in development and staging

- [x] **Service Layer**
  - [x] Create ContentService in `packages/content/src/services/content-service.ts`
  - [x] Create MediaItemService in `packages/content/src/services/media-service.ts`
  - [x] Implement custom error classes (ContentNotFoundError, etc.)
  - [x] Add unit tests with mocked database

- [x] **Validation**
  - [x] Add Zod schemas to `@codex/validation`
  - [x] Ensure enums match database CHECK constraints
  - [x] Add schema tests (100% coverage)

- [x] **Worker/API**
  - [x] Create content-api worker with Hono routes
  - [x] Implement endpoints using createAuthenticatedHandler()
  - [x] Apply route-level security with withPolicy()
  - [x] Add integration tests with real database

- [x] **Integration**
  - [x] Wire ContentService into content-api worker
  - [x] Test end-to-end workflows (create â†’ publish â†’ delete)
  - [x] Verify creator scoping and organization filtering
  - [x] Update package CLAUDE.md documentation

- [x] **Deployment**
  - [x] Update wrangler.jsonc with database bindings
  - [x] Test in preview environment
  - [x] Run migrations in staging
  - [x] Deploy to production

---

## Testing Strategy

### Unit Tests

**Service Layer** (`packages/content/src/__tests__/`):
- Test business logic in isolation with mocked database
- Verify error handling (custom error classes thrown correctly)
- Test creator scoping (queries include creatorId filter)
- Test transaction boundaries (rollback on failure)
- Verify media ownership validation
- Test soft delete behavior

**Validation Layer** (`packages/validation/src/__tests__/`):
- 100% coverage requirement for all Zod schemas
- Test valid inputs, invalid inputs, edge cases
- Verify enum values match database constraints
- Test XSS prevention (sanitizedString)

### Integration Tests

**API Endpoints** (`workers/content-api/src/__tests__/`):
- Test full request-response cycle with real database
- Test authentication/authorization (various user roles)
- Verify response formats match @codex/shared-types
- Test error responses (4xx, 5xx status codes)
- Test creator isolation (creator A cannot access creator B's content)
- Test organization scoping (org vs personal content)

**Database Tests**:
- Test constraints (unique slug, foreign keys)
- Verify soft delete (deletedAt filtering)
- Test scoping (creator/organization isolation)
- Test transaction rollback on error

### E2E Scenarios

**Primary Creator Workflow**:
1. Upload media â†’ transcoding completes â†’ media status = 'ready'
2. Create draft content referencing media
3. Update content metadata (title, pricing)
4. Publish content â†’ status changes, publishedAt set
5. Access service verifies content is published
6. Unpublish content â†’ revert to draft
7. Soft delete content â†’ deletedAt set

**Error Scenario - Media Not Ready**:
1. Upload media â†’ media status = 'transcoding'
2. Create draft content â†’ succeeds
3. Attempt to publish content â†’ throws MediaNotReadyError
4. Wait for transcoding â†’ media status = 'ready'
5. Publish content â†’ succeeds

### Local Development Testing

**Tools**:
- `pnpm test`: Run all tests (validation, service, integration)
- `pnpm --filter @codex/content test:watch`: Watch mode for development
- `pnpm dev`: Local worker development server
- Database: Local PostgreSQL via Docker

**Test Data**:
- Use `@codex/test-utils` to seed test creators and media
- Deterministic UUIDs for repeatability
- Cleanup after each test

---

## Notes

### Implementation Enhancements

The actual implementation exceeds the original specification:

1. **Separate MediaItemService**: Originally media and content were in one service. Separated for better single responsibility and reusability.

2. **Transaction Safety**: Uses `db.transaction()` for atomic operations ensuring ACID compliance.

3. **Route-Level Security**: Uses `withPolicy()` per route instead of global auth middleware for more granular control.

4. **Custom Error Classes**: Domain-specific errors (ContentNotFoundError, MediaNotReadyError) instead of generic errors.

5. **Text-based User IDs**: Uses `text` instead of `uuid` for creator IDs to match Clerk Auth system.

### Architectural Decisions

**Media Separation**: Media items are tracked independently from content to enable a media library pattern (one media item â†’ multiple content pieces).

**Soft Deletes**: Content is never hard-deleted to preserve purchase history and analytics. All queries filter `deletedAt IS NULL`.

**Creator Scoping**: All operations are scoped to creator ID. No cross-creator access in Phase 1. Admin access (P1-ADMIN-001) bypasses creator scoping.

**Organization vs Personal**: Content with `organizationId` belongs to organization. NULL organizationId means personal content. Creator can have both.

**Slug Uniqueness**: Slugs are unique per organization (not globally) to support multi-tenant SEO-friendly URLs.

### Phase 1 Limitations

**Simplified Schema**:
- Category is a simple string field (no normalization, no validation)
- Tags stored as JSONB array (no normalization, hard to query efficiently)
- Future: Normalize to separate tables with foreign keys

**Content Types**:
- Phase 1 supports only video and audio
- Written content (`contentType = 'written'`) reserved for Phase 2

**No Content Series**:
- Content items are standalone
- Future: Add series/collections with `content.seriesId` FK

**No Content Versioning**:
- Updates overwrite existing data
- Future: Add `content_versions` table for history

**No Full-Text Search**:
- Basic LIKE queries only
- Future: PostgreSQL full-text search or Algolia

### Performance Considerations

**Expected Query Performance**:
- List content (creator-scoped): < 50ms (indexed on creator_id)
- Get single content: < 10ms (primary key lookup)
- Media validation: < 20ms (indexed media_items)

**Database Load** (Phase 1 estimates):
- Content creation: ~10-100/day
- Content reads: ~1,000-10,000/day (via access service)
- Total content rows: ~1,000 (Phase 1)
- Storage: < 1 MB (metadata only, media in R2)

**Indexes are critical**:
- `creator_id` index: Used in 90% of queries
- `slug` composite index: SEO-friendly URL lookups
- `published_at`, `status` indexes: Access service filtering

---

**Last Updated**: 2025-11-23
**Version**: 4.0 (Updated to architectural documentation standard)
