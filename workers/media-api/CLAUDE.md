# Media-API Worker

Cloudflare Worker that orchestrates media transcoding via RunPod GPU infrastructure. Manages the complete transcoding lifecycle: triggering jobs, receiving webhook callbacks, updating media status, handling retries, and tracking progress.

**Deployment**: `media-api.revelations.studio` (production), local port 4002 (dev)

**Business Responsibility**: Media transcoding orchestration, webhook processing, job status management

**Architecture**: Hono framework + @codex/transcoding service + worker-to-worker HMAC auth + RunPod webhook verification

---

## Quick Overview

Media-API coordinates video/audio transcoding across three system components:

```
Content-API          Media-API           RunPod (External)
    |                   |                     |
    |--trigger-------->|                     |
    |             triggerJob()               |
    |             (worker auth HMAC)         |
    |                   |--POST /run-------->|
    |                   |                    |
    |                   |        (GPU processes)
    |                   |                    |
    |                   |<--webhook POST----|
    |                   | handleWebhook()   |
    |    <--update--|  (HMAC verified)      |
    |               |                       |
    | (media ready) |                       |
```

**Three Types of Traffic**:
1. **Internal (Worker-to-Worker)**: Content-API calls `/internal/media/:id/transcode` with HMAC signature
2. **User-Facing**: Authenticated users can retry failed jobs and check status
3. **Webhooks**: RunPod POSTs completed job results with HMAC-SHA256 signature

---

## Public API

### 1. Health Check (Public)

**GET /health**

Health status endpoint for monitoring.

Response (200 or 503):
```json
{
  "status": "healthy",
  "service": "media-api",
  "version": "1.0.0",
  "timestamp": "2025-01-11T12:34:56.000Z",
  "checks": {
    "database": "healthy",
    "kv_rate_limit": "healthy"
  }
}
```

---

### 2. Internal Transcoding Trigger (Worker-to-Worker)

**POST /internal/media/:id/transcode**

Trigger transcoding for a media item. Called by content-api after media upload completes.

**Security**: Worker authentication (HMAC-SHA256 signature)
- Signature generated by calling worker using shared secret
- Verified by media-api before processing
- Only workers with WORKER_SHARED_SECRET can access

**Rate Limit**: None (internal only, rate limited at caller)

**URL Parameters**:
- `id` (string, UUID): Media item UUID

**Request Body**:
```typescript
{
  priority?: number;  // Optional job priority (0=urgent, 2=normal, 4=backlog)
}
```

**Response (200 OK)**:
```json
{
  "message": "Transcoding job triggered",
  "mediaId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Error Responses**:
- 401 Unauthorized: Missing or invalid worker signature
- 404 Not Found: Media item doesn't exist
- 422 Invalid Media State: Media not in 'uploaded' status
- 502 RunPod API Error: Failed to create job on RunPod
- 500 Internal Server Error: Database or service failure

**When Used**: Content-API calls this after user uploads media file to R2. Marks media status as 'uploading' → 'uploaded', then triggers transcoding via this endpoint.

**Example**:
```bash
curl -X POST http://localhost:4002/internal/media/550e8400-e29b-41d4-a716-446655440000/transcode \
  -H "Content-Type: application/json" \
  -H "X-Worker-Signature: <HMAC-SHA256 signature>" \
  -H "X-Worker-Timestamp: $(date +%s)" \
  -d '{
    "priority": 2
  }'
```

---

### 3. Get Transcoding Status (Authenticated)

**GET /api/transcoding/status/:id**

Get current transcoding status for a media item.

**Security**: Session authentication (user must own media)

**Rate Limit**: API (100 requests/min)

**URL Parameters**:
- `id` (string, UUID): Media item UUID

**Response (200 OK)**:
```json
{
  "data": {
    "status": "transcoding",
    "transcodingAttempts": 0,
    "transcodingError": null,
    "runpodJobId": "sync-job-123456789",
    "transcodingPriority": 2,
    "readyVariants": null
  }
}
```

**Status Values**:
- `uploading` - File being uploaded to R2
- `uploaded` - File uploaded, ready for transcoding
- `transcoding` - Currently being transcoded on RunPod
- `ready` - Transcoding complete, all outputs ready
- `failed` - Transcoding failed (see transcodingError)

**Error Responses**:
- 401 Unauthorized: Not authenticated
- 404 Not Found: Media doesn't exist or not owned by user
- 429 Too Many Requests: Rate limit exceeded
- 500 Internal Server Error: Database error

**Example**:
```bash
curl http://localhost:4002/api/transcoding/status/550e8400-e29b-41d4-a716-446655440000 \
  -H "Cookie: codex-session=<session>" \
  -H "Accept: application/json"
```

---

### 4. Retry Failed Transcoding (Authenticated)

**POST /api/transcoding/retry/:id**

Retry a failed transcoding job. Only 1 retry allowed per media item (max 3 total attempts).

**Security**: Session authentication (user must own media)

**Rate Limit**: Auth (10 requests/min - stricter for mutations)

**URL Parameters**:
- `id` (string, UUID): Media item UUID

**Request Body**: Empty

**Response (200 OK)**:
```json
{
  "message": "Transcoding retry triggered",
  "mediaId": "550e8400-e29b-41d4-a716-446655440000"
}
```

**Error Responses**:
- 401 Unauthorized: Not authenticated
- 404 Not Found: Media doesn't exist or not owned by user
- 409 Conflict: Max retries (3) exceeded
- 422 Invalid Media State: Media not in 'failed' status
- 429 Too Many Requests: Rate limit exceeded
- 502 RunPod API Error: Failed to create job on RunPod
- 500 Internal Server Error: Database or service failure

**Example**:
```bash
curl -X POST http://localhost:4002/api/transcoding/retry/550e8400-e29b-41d4-a716-446655440000 \
  -H "Cookie: codex-session=<session>"
```

---

### 5. RunPod Webhook Callback (HMAC Verified)

**POST /api/transcoding/webhook**

Receive transcoding completion callbacks from RunPod. Updates media status and metadata with transcoding results.

**Security**: HMAC-SHA256 signature verification (timing-safe)
- Signature in `X-Runpod-Signature` header
- Timestamp in `X-Runpod-Timestamp` header (for replay protection)
- No session authentication required
- Signature must match `SHA256(body, RUNPOD_WEBHOOK_SECRET)`

**Rate Limit**: High throughput (webhook events not rate limited)

**Request Headers**:
- `X-Runpod-Signature` (required): HMAC-SHA256 signature (hex encoded)
- `X-Runpod-Timestamp` (required): Unix timestamp for replay protection
- `Content-Type`: application/json

**Request Body**:
```typescript
{
  jobId: string;           // RunPod job ID
  status: 'completed' | 'failed';
  output?: {               // Only present if status='completed'
    mediaId: string;
    type: 'video' | 'audio';
    hlsMasterKey: string;   // R2 key to HLS master playlist
    hlsPreviewKey?: string; // R2 key to preview clip
    thumbnailKey?: string;  // R2 key to thumbnail image
    waveformKey?: string;   // R2 key to waveform JSON
    waveformImageKey?: string; // R2 key to waveform image
    durationSeconds: number;
    width?: number;         // Video only
    height?: number;        // Video only
    readyVariants: string[]; // HLS variants that succeeded
    loudnessIntegrated?: number;
    loudnessPeak?: number;
    loudnessRange?: number;
  };
  error?: string;          // Only present if status='failed'
}
```

**Response (200 OK)**:
```json
{
  "received": true
}
```

**Error Responses**:
- 401 Unauthorized: Missing/invalid signature or expired timestamp
- 400 Bad Request: Invalid JSON or schema validation failed
- 404 Not Found: No media found for job ID
- 422 Unprocessable Entity: Validation error in payload
- 500 Internal Server Error: Database or service failure

**Important Notes**:
1. Webhook must return 200 OK to prevent RunPod retries
2. Signature verification is timing-safe (prevents timing attacks)
3. Timestamp must be within 5 minutes of current time
4. Database update is atomic (prevents race conditions)
5. If media no longer in 'transcoding' state, webhook is ignored (concurrent update)

**Example** (with signature generation):
```bash
# Generate signature
PAYLOAD='{"jobId":"sync-123","status":"completed","output":{"mediaId":"550e8400...","type":"video","hlsMasterKey":"..."}}'
TIMESTAMP=$(date +%s)
SIGNATURE=$(echo -n "$TIMESTAMP.$PAYLOAD" | \
  openssl dgst -sha256 -hmac "your-webhook-secret" -hex | \
  cut -d' ' -f2)

curl -X POST http://localhost:4002/api/transcoding/webhook \
  -H "Content-Type: application/json" \
  -H "X-Runpod-Signature: $SIGNATURE" \
  -H "X-Runpod-Timestamp: $TIMESTAMP" \
  -d "$PAYLOAD"
```

---

## Architecture & Integration Points

### Request Flow

**Transcoding Trigger Flow**:
```
1. Content-API: POST /internal/media/:id/transcode (with worker signature)
   ↓
2. Media-API: Verify HMAC-SHA256 signature via procedure()
   ↓
3. Media-API: Call TranscodingService.triggerJobInternal()
   ↓
4. Service: Fetch media item from PostgreSQL
   ↓
5. Service: Validate media is in 'uploaded' status
   ↓
6. Service: POST to RunPod /run endpoint with job request
   ↓
7. RunPod: Returns { id: "job-123", status: "IN_QUEUE" }
   ↓
8. Service: Update media status to 'transcoding' in PostgreSQL
   ↓
9. Media-API: Return success response
```

**Webhook Processing Flow**:
```
1. RunPod: POST /api/transcoding/webhook with completed job results
   ↓
2. Media-API: Verify HMAC-SHA256 signature (timing-safe)
   ↓
3. Media-API: Validate timestamp (replay protection, max 5 min age)
   ↓
4. Media-API: Parse & validate JSON schema
   ↓
5. Media-API: Create TranscodingService instance
   ↓
6. Service: Call handleWebhook() with validated payload
   ↓
7. Service: Find media by jobId or mediaId from output
   ↓
8. Service: Atomic update media with transcoding results
   ↓
9. Service: Clear transcodingError on success, set all output keys
   ↓
10. Media-API: Return 200 OK (acknowledges receipt to RunPod)
```

**Retry Flow**:
```
1. User: POST /api/transcoding/retry/:id (authenticated)
   ↓
2. Media-API: Verify session authentication
   ↓
3. Service: Fetch media, verify ownership and 'failed' status
   ↓
4. Service: Atomic conditional update (fails if max retries exceeded)
   ↓
5. Service: Call triggerJob() to submit new RunPod job
   ↓
6. Media-API: Return success response
```

### Service Integration

**TranscodingService** (@codex/transcoding):
- Extends BaseService from @codex/service-errors
- Receives database client (dbHttp) and environment config
- Key methods:
  - `triggerJobInternal(mediaId, priority?)` - Used by internal route
  - `triggerJob(mediaId, creatorId, priority?)` - Used by retry endpoint
  - `handleWebhook(payload)` - Processes RunPod callbacks
  - `retryTranscoding(mediaId, creatorId)` - Retry failed jobs
  - `getTranscodingStatus(mediaId, creatorId)` - Get current status

**Database Integration** (@codex/database):
- Reads from `mediaItems` table:
  - `id` - Media UUID
  - `status` - Current status (uploading, uploaded, transcoding, ready, failed)
  - `r2Key` - Path to original file in R2
  - `transcodingAttempts` - Number of retry attempts (0-3)
  - `runpodJobId` - RunPod job ID from last submission
  - `transcodingError` - Error message if failed
  - `transcodingPriority` - Job priority level
- Updates metadata on webhook:
  - `hlsMasterPlaylistKey` - Path to HLS master playlist
  - `hlsPreviewKey` - Path to preview clip
  - `thumbnailKey` - Path to thumbnail
  - `waveformKey` - Path to audio waveform
  - `waveformImageKey` - Path to waveform image
  - `durationSeconds` - Duration of content
  - `width` / `height` - Video dimensions
  - `readyVariants` - HLS quality levels available
  - `loudnessIntegrated`, `loudnessPeak`, `loudnessRange` - Audio metrics

**Security Integration** (@codex/security):
- `workerAuth` policy for internal endpoint
  - Verifies HMAC-SHA256 signature
  - Uses WORKER_SHARED_SECRET
  - Prevents unauthorized service calls
- `requireAuth` policy for user endpoints
  - Validates session cookie
  - Verifies user ownership of media
- Rate limiting via KV:
  - Auth endpoints: 10/min
  - API endpoints: 100/min

**Worker Utils** (@codex/worker-utils):
- `createWorker()` - Standard Hono app setup with:
  - Request tracking (requestId, clientIP, userAgent)
  - Logging middleware
  - Security headers (CSP, X-Frame-Options, HSTS)
  - CORS configuration
  - Health check endpoint
  - Error handling
- `procedure()` - Unified route handler with:
  - Policy enforcement (auth, rate limiting)
  - Input validation (Zod schemas)
  - Service injection via context
  - Automatic error mapping

---

## Error Handling

### Error Classes & HTTP Status Mapping

**TranscodingMediaNotFoundError** (404)
- Thrown when: Media item doesn't exist or user doesn't own it
- Cause: Invalid mediaId or permission denied
- Recovery: Verify mediaId is correct and user owns media
- Example: `await service.getTranscodingStatus(invalidId, userId)`

**InvalidMediaStateError** (422)
- Thrown when: Media not in correct state for operation
- Cause: Media already transcoding, not uploaded, etc.
- Recovery: Check media status before retrying operation
- States required:
  - triggerJob: 'uploaded'
  - retryTranscoding: 'failed'
  - handleWebhook: 'transcoding'
- Example: Trying to transcode media already in 'ready' state

**MaxRetriesExceededError** (409)
- Thrown when: Max retry attempts (3) exceeded
- Cause: Media failed transcoding, user attempted 4th retry
- Recovery: Contact support or re-upload media
- Max attempts: 3 total (1 initial + 2 retries)
- Example: `await service.retryTranscoding(mediaId, userId)` on 4th attempt

**RunPodApiError** (502)
- Thrown when: RunPod API call fails
- Cause: RunPod service down, invalid credentials, timeout
- Recovery: Retry operation after delay; verify RUNPOD_API_KEY and RUNPOD_ENDPOINT_ID
- Details: Includes HTTP status code and response body
- Example: RunPod returns 500, network timeout, invalid auth

**MediaOwnershipError** (403)
- Thrown when: User doesn't own the media
- Cause: User trying to retry/check status of another user's media
- Recovery: Verify user is owner before operation
- Example: User A trying to get status of User B's media

**TranscodingJobNotFoundError** (404)
- Thrown when: No media found for RunPod jobId
- Cause: Webhook received for completed job with unknown mediaId
- Recovery: Typically ignored (webhook logged as unknown)
- Example: Webhook callback for deleted media

**InvalidMediaTypeError** (400)
- Thrown when: Media type is neither 'video' nor 'audio'
- Cause: Invalid mediaType value in database or request
- Recovery: Fix media type in database or request validation
- Example: mediaType = 'image' (not supported)

### Handling Strategy

**In procedure() Routes**:
```typescript
app.post('/api/transcoding/retry/:id',
  procedure({
    policy: { auth: 'required' },
    input: { params: idParamSchema },
    handler: async (ctx) => {
      // Services throw specific errors
      await ctx.services.transcoding.retryTranscoding(id, ctx.user.id);
      // procedure() catches and maps to HTTP response
    },
  })
);

// Error responses automatically:
// NotFoundError → 404
// ValidationError → 400
// ForbiddenError → 403
// BusinessLogicError → 422
// InternalServiceError → 500
```

**In Webhook Route** (manual error handling):
```typescript
app.post('/api/transcoding/webhook',
  verifyRunpodSignature(),
  async (c) => {
    try {
      const rawBody = c.get('rawBody');
      const payload = runpodWebhookSchema.parse(JSON.parse(rawBody));
      await service.handleWebhook(payload);
      return c.json({ received: true }, 200);
    } catch (error) {
      // mapErrorToResponse handles conversion
      const { statusCode, response } = mapErrorToResponse(error);
      return c.json(response, statusCode);
    }
  }
);
```

**Example Error Responses**:
```json
// 404 Not Found
{
  "error": {
    "code": "TRANSCODING_MEDIA_NOT_FOUND",
    "message": "Media item not found",
    "details": { "mediaId": "..." }
  }
}

// 422 Invalid Media State
{
  "error": {
    "code": "INVALID_MEDIA_STATE",
    "message": "Media must be in 'failed' status to perform this operation",
    "details": {
      "mediaId": "...",
      "currentStatus": "transcoding",
      "requiredStatus": "failed"
    }
  }
}

// 409 Max Retries Exceeded
{
  "error": {
    "code": "MAX_RETRIES_EXCEEDED",
    "message": "Maximum transcoding retry attempts exceeded",
    "details": {
      "mediaId": "...",
      "attempts": 3,
      "maxAttempts": 3
    }
  }
}

// 502 RunPod API Error
{
  "error": {
    "code": "RUNPOD_API_ERROR",
    "message": "RunPod API error during triggerJob",
    "details": {
      "operation": "triggerJob",
      "statusCode": 503
    }
  }
}
```

---

## Security Model

### Authentication

**Internal Endpoints** (Worker-to-Worker):
- Uses HMAC-SHA256 signature verification
- Signature in `Authorization` header (via procedure workerAuth)
- Secret: `WORKER_SHARED_SECRET` (shared across all workers)
- Generated by caller using `workerFetch()` or `generateWorkerSignature()`
- Timestamp included for replay protection

**User Endpoints** (Authenticated):
- Uses session cookie authentication
- Cookie: `codex-session` (HttpOnly, Secure, SameSite=Strict)
- Validated via Auth Worker GET /api/auth/session
- Session cached in KV (5min TTL) to reduce database load
- User ID extracted from session and used for ownership checks

**Webhook Endpoints** (Signature Verified):
- Uses HMAC-SHA256 signature verification
- Signature in `X-Runpod-Signature` header (hex encoded)
- Secret: `RUNPOD_WEBHOOK_SECRET`
- Verification is timing-safe (prevents timing attacks)
- Timestamp validation (max 5 min age) prevents replay attacks

### Authorization

**Creator Scoping**:
- All database queries filtered by `creatorId`
- Users can only access their own media
- Service throws `MediaOwnershipError` (403) if user doesn't own media

**Internal Route Authorization**:
- Only called by content-api (verified via HMAC)
- Skips creatorId check (auth layer is HMAC, not session)
- Used `triggerJobInternal()` method

**Retry Endpoint Authorization**:
- User must own the media
- Verified by service.getMediaForTranscoding(mediaId, creatorId)
- Throws NotFoundError (404) if media not owned

**Webhook Authorization**:
- No user context (webhook is not user-initiated)
- Authenticated via HMAC signature only
- Payload must match RUNPOD_WEBHOOK_SECRET

### Rate Limiting

**Via KV namespace** (RATE_LIMIT_KV):

| Endpoint | Limit | Key | Enforcement |
|---|---|---|---|
| GET /api/transcoding/status/:id | 100/min | User ID | API preset |
| POST /api/transcoding/retry/:id | 10/min | User ID | Auth preset (stricter) |
| POST /api/transcoding/webhook | None | N/A | Webhook events not limited |
| POST /internal/media/:id/transcode | N/A | N/A | Internal only |

**Implementation**: `procedure()` enforces via `policy.rateLimit` configuration

### Input Validation

**Zod Schemas**:
- All route inputs validated via Zod schemas
- Returns 400 Bad Request if validation fails
- Prevents injection attacks, XSS, path traversal

**Specific Validations**:
- UUIDs: Must be valid UUID v4
- Timestamps: Must be valid Unix seconds
- Signatures: Must be 64 hex characters (SHA-256)
- Job IDs: No format constraints (RunPod specific)
- Priorities: Must be 0-100 if provided

### Security Headers

Applied to all responses:
- `Content-Security-Policy`: Restricts resource loading
- `X-Content-Type-Options`: nosniff (prevents MIME sniffing)
- `X-Frame-Options`: SAMEORIGIN (clickjacking protection)
- `Referrer-Policy`: strict-origin-when-cross-origin
- `Strict-Transport-Security`: max-age=31536000 (HSTS, prod only)

### PII Handling

**What's Logged**:
- Request/response status, method, path, duration
- Error codes and messages
- Media IDs and job IDs
- User IDs

**What's NOT Logged**:
- Request/response bodies (contains PII)
- User names or email addresses
- Raw error stack traces (development only)

---

## RunPod Integration Details

### RunPod Job Request Format

```typescript
// Sent to RunPod /v2/{endpoint_id}/run endpoint
{
  input: {
    mediaId: string;           // UUID of media item
    type: 'video' | 'audio';   // Content type
    creatorId: string;         // Owner (for path generation)
    inputKey: string;          // R2 path to original file
    webhookUrl: string;        // Where to POST results
    priority?: number;         // 0=urgent, 2=normal, 4=backlog
  }
}
```

### RunPod Async Pattern

RunPod `/run` endpoint is asynchronous (fire-and-forget):

1. **Trigger**: Service calls POST /v2/{endpoint_id}/run
2. **Immediate Response**: RunPod returns `{ id: "job-123", status: "IN_QUEUE" }`
3. **Background Processing**: GPU worker processes job (minutes to hours)
4. **Webhook Callback**: RunPod POSTs results to webhookUrl
5. **Status Tracking**: Service updates database from webhook (not polling)

**Important**: `triggerJob()` returns immediately after RunPod accepts the job. Actual transcoding happens asynchronously. Status is updated later via webhook callback.

### RunPod Credentials

**Configuration** (via environment variables):
- `RUNPOD_API_KEY` - API key for authentication
- `RUNPOD_ENDPOINT_ID` - Endpoint ID for transcoding
- `RUNPOD_WEBHOOK_SECRET` - Secret for webhook signature verification

**Security**: Never pass B2/R2 credentials in job payload. Instead:
- Credentials configured in RunPod's secret manager
- Injected as environment variables on RunPod workers
- Job payload only references storage paths (R2 keys, B2 keys)
- Prevents credential leakage in logs or error messages

---

## Testing Approach

### Unit Tests

**Signature Verification** (`middleware/__tests__/verify-runpod-signature.test.ts`):
```typescript
// Test timing-safe comparison
// Test signature validation with correct/invalid signatures
// Test timestamp validation (age, future timestamps)
// Test malformed signatures
// Test missing headers
```

### Integration Tests

**Endpoints** (`src/__tests__/endpoints.test.ts`):
```typescript
// Health check returns 200 or 503
// Webhook rejects missing signature (401)
// Webhook rejects invalid signature (401)
// Webhook rejects expired timestamp (401)
// Webhook returns 200 on valid signature
```

**Service Tests** (`packages/transcoding/__tests__/transcoding-service.test.ts`):
```typescript
// triggerJob updates media status to 'transcoding'
// triggerJob calls RunPod API with correct payload
// handleWebhook marks media as 'ready' with all outputs
// handleWebhook stores error message on failure
// retryTranscoding increments attempt counter
// retryTranscoding fails at max retries
// getTranscodingStatus returns correct status
```

### Local Testing

**Run Tests**:
```bash
cd workers/media-api
pnpm test              # Run once
pnpm test:watch       # Watch mode
pnpm test:coverage    # With coverage
```

**Test Database**:
- Uses Neon ephemeral branches (via @codex/test-utils)
- Each test file gets isolated branch
- Data cleaned up automatically after test

**Mock RunPod**:
- Tests mock fetch() to RunPod API
- Simulate successful/failed responses
- Verify correct payload format

**Test Webhook Signature**:
```typescript
// Generate valid signature
const secret = 'test-secret';
const payload = '{"jobId":"test"}';
const timestamp = Math.floor(Date.now() / 1000).toString();
const message = `${timestamp}.${payload}`;
const signature = await crypto.subtle.sign(
  'HMAC',
  await crypto.subtle.importKey('raw', new TextEncoder().encode(secret),
    { name: 'HMAC', hash: 'SHA-256' }, false, ['sign']),
  new TextEncoder().encode(message)
);
const hexSignature = Array.from(new Uint8Array(signature))
  .map(b => b.toString(16).padStart(2, '0'))
  .join('');

// Send webhook with signature
const response = await fetch('/api/transcoding/webhook', {
  method: 'POST',
  headers: {
    'X-Runpod-Signature': hexSignature,
    'X-Runpod-Timestamp': timestamp,
  },
  body: payload,
});
```

---

## Development & Deployment

### Local Setup

**Environment Variables** (`.env.local`):
```
ENVIRONMENT=development
DATABASE_URL=postgresql://user:pass@localhost:5432/codex_dev
RUNPOD_API_KEY=sk_...
RUNPOD_ENDPOINT_ID=endpoint_...
RUNPOD_WEBHOOK_SECRET=whsec_...
WORKER_SHARED_SECRET=<32+ char random>
RATE_LIMIT_KV=rate-limit-dev
AUTH_SESSION_KV=auth-session-dev
B2_ENDPOINT=https://s3.us-west-000.backblazeb2.com
B2_KEY_ID=<b2-app-key-id>
B2_APP_KEY=<b2-app-key>
B2_BUCKET=codex-mezzanine-dev
API_URL=http://localhost:4002
WEB_APP_URL=http://localhost:5173
```

**Start Locally**:
```bash
cd workers/media-api
pnpm dev
# Starts on http://localhost:4002
```

### Testing with RunPod

**Option 1: Mock RunPod in Tests**:
```typescript
// Use vitest mocks to simulate RunPod responses
vi.mock('fetch', () => ({
  default: vi.fn().mockResolvedValue({
    ok: true,
    json: async () => ({ id: 'job-123' }),
  }),
}));
```

**Option 2: Use RunPod Staging**:
```bash
# Set environment to RunPod staging endpoint
RUNPOD_ENDPOINT_ID=staging-endpoint-xxx
pnpm dev
```

**Option 3: Simulate Webhook Callback**:
```bash
# Manually call webhook endpoint after triggering job
curl -X POST http://localhost:4002/api/transcoding/webhook \
  -H "Content-Type: application/json" \
  -H "X-Runpod-Signature: <valid-signature>" \
  -H "X-Runpod-Timestamp: <timestamp>" \
  -d '{
    "jobId": "sync-123",
    "status": "completed",
    "output": {
      "mediaId": "550e8400-e29b-41d4-a716-446655440000",
      "type": "video",
      "hlsMasterKey": "user-123/hls/550e8400.../master.m3u8",
      "durationSeconds": 120,
      "readyVariants": ["1080p", "720p", "480p"]
    }
  }'
```

### Staging Deployment

```bash
# Deploy to staging
wrangler deploy --env staging

# Verify health check
curl https://media-api-staging.revelations.studio/health

# Check logs
wrangler tail --env staging
```

### Production Deployment

```bash
# Run all tests first
pnpm test

# Deploy
wrangler deploy --env production

# Verify
curl https://media-api.revelations.studio/health
```

**Environment Secrets** (set via Wrangler CLI):
```bash
wrangler secret put RUNPOD_API_KEY --env production
wrangler secret put RUNPOD_WEBHOOK_SECRET --env production
wrangler secret put WORKER_SHARED_SECRET --env production
wrangler secret put DATABASE_URL --env production
```

---

## Monitoring & Observability

### Health Checks

**Endpoint**: GET /health

**What's Checked**:
- Database connectivity (PostgreSQL)
- KV namespace availability (RATE_LIMIT_KV)

**Response Codes**:
- 200: All systems healthy
- 503: Database or KV unavailable

### Logging

**Request Metadata Logged**:
- Request ID (UUID)
- Client IP address
- User agent
- HTTP method and path
- Response status code
- Response time (milliseconds)
- User ID (if authenticated)

**Service Events Logged**:
- Job submission: `'Transcoding job started'`
- Webhook receipt: `'Processing transcoding webhook'`
- Completion: `'Transcoding completed successfully'`
- Failure: `'Transcoding failed'`
- Retry: `'Transcoding retry triggered'`

**What's NOT Logged** (PII Protection):
- Request/response bodies
- User names or emails
- Raw credentials
- Full stack traces (summary only)

### Error Monitoring

**Errors to Alert On**:
- RunPod API failures (502)
- Database connectivity issues (500)
- Webhook signature validation failures (401)
- Systematic max retry failures (409)

**Webhook Failure Patterns**:
- Unknown media IDs (404) - possible deleted media
- TOCTOU race conditions (media no longer transcoding)
- Timestamp expired (401) - clock skew or network delay

---

## Critical Files & Locations

| File | Purpose |
|------|---------|
| `/src/index.ts` | Main worker app setup, routes mounting |
| `/src/routes/transcoding.ts` | Internal trigger, retry, status endpoints |
| `/src/routes/webhook.ts` | RunPod webhook callback handler |
| `/src/middleware/verify-runpod-signature.ts` | HMAC signature verification |
| `/src/__tests__/endpoints.test.ts` | Integration tests |
| `/src/__tests__/middleware/verify-runpod-signature.test.ts` | Signature verification tests |
| `packages/transcoding/src/services/transcoding-service.ts` | Core business logic |
| `packages/transcoding/src/errors.ts` | Domain-specific error classes |
| `packages/transcoding/src/paths.ts` | R2/B2 path generation (SINGLE SOURCE OF TRUTH) |
| `packages/transcoding/src/types.ts` | Type definitions, schema exports |

---

## Key Concepts

### RunPod Async Pattern

Understanding the async nature is critical:

```
Timeline:
T0:   Service calls triggerJob()
      → POST to RunPod /run endpoint
      → Returns immediately with { id: "job-123" }
      ✓ Status = 'transcoding'

T0-60min: GPU worker processes job
         (actual encoding happening)

T60min:  Job completes
         RunPod POSTs webhook result
         → Service.handleWebhook() called
         ✓ Status = 'ready' (success) or 'failed'
```

**Implication**: You cannot poll for status. You must rely on webhooks.

### Atomic Updates & Race Conditions

Media status updates use conditional WHERE clauses to prevent TOCTOU:

```typescript
// This succeeds only if media is still in 'transcoding' state
const result = await db
  .update(mediaItems)
  .set({ status: 'ready', ... })
  .where(
    and(
      eq(mediaItems.id, mediaId),
      eq(mediaItems.status, 'transcoding')  // ← Conditional
    )
  )
  .returning();

// If concurrent request already updated status, result.length === 0
if (result.length === 0) {
  // Media already updated, skip (idempotent)
  return;
}
```

This prevents:
1. **TOCTOU Race**: Check-then-act split by concurrent request
2. **Duplicate Webhook Processing**: Multiple callbacks for same job
3. **Inconsistent State**: Media status overwritten by stale data

### Path Generation (SINGLE SOURCE OF TRUTH)

All R2/B2 paths generated from `paths.ts`:

```typescript
// ✓ CORRECT: Use path utility
import { getHlsMasterKey } from '@codex/transcoding';
const key = getHlsMasterKey(creatorId, mediaId);

// ✗ WRONG: Hardcoding path
const key = `${creatorId}/hls/${mediaId}/master.m3u8`;
```

**Why**: Ensures consistency. If path structure changes, update only in `paths.ts`, not scattered throughout codebase.

---

## Integration Checklist

**For Content-API Integration**:
- [ ] Import `generateWorkerSignature()` from @codex/security
- [ ] After media upload succeeds, call media-api internal endpoint
- [ ] Include HMAC signature in Authorization header
- [ ] Pass optional priority (0=urgent, 2=normal, 4=backlog)
- [ ] Handle errors: 401, 404, 422, 502, 500

**For Frontend Integration**:
- [ ] Display media status from GET /api/transcoding/status/:id
- [ ] Poll status every 5-10 seconds (while status !== 'ready')
- [ ] Show error message from transcodingError field
- [ ] Provide retry button after failure (but check transcodingAttempts < 3)
- [ ] After 'ready', start generating streaming URLs via content-api

**For Monitoring**:
- [ ] Monitor GET /health endpoint for downtime
- [ ] Alert on 502 RunPod errors (RunPod service down)
- [ ] Alert on 401 webhook errors (signature verification failed)
- [ ] Track webhook processing time (should be < 1s)

---

## Troubleshooting

### Issue: "401 Unauthorized" on Internal Endpoint

**Causes**:
1. Missing X-Worker-Signature header
2. Incorrect WORKER_SHARED_SECRET
3. Signature timestamp too old (> 5 min)
4. Calling worker not using generateWorkerSignature()

**Solutions**:
- Verify content-api is calling with correct signature
- Check WORKER_SHARED_SECRET matches across workers
- Verify system clocks are synchronized
- Check generateWorkerSignature() implementation

### Issue: Webhook Returns 401 "Invalid Signature"

**Causes**:
1. Wrong RUNPOD_WEBHOOK_SECRET
2. Body modified after signature generation
3. Signature encoding issue (should be hex)
4. Raw body not read (parsed JSON before signature check)

**Solutions**:
- Verify RUNPOD_WEBHOOK_SECRET matches RunPod settings
- Ensure raw body text is used for verification, not parsed JSON
- Check signature is hex encoded (not base64)
- Test with local mock webhook before running live

### Issue: Media Status Stuck in "Transcoding"

**Causes**:
1. RunPod job crashed (no webhook sent)
2. Webhook URL misconfigured
3. Database update failed
4. Network partition between RunPod and media-api

**Solutions**:
- Check RunPod job status manually (RunPod dashboard)
- Verify webhookUrl in service config is correct
- Check database connectivity (GET /health)
- User can retry via POST /api/transcoding/retry/:id

### Issue: "Max Retries Exceeded" Error

**Causes**:
1. User attempted 4th retry (max 3 total)
2. Media legitimately cannot transcode (corrupted file, unsupported codec)

**Solutions**:
- Contact support for manual retry authorization
- Re-upload media file (may be corrupted)
- Check RunPod logs for transcoding errors

---

## Summary

Media-API coordinates the entire media transcoding lifecycle for Codex. It bridges content management (content-api) and GPU transcoding (RunPod) through a clean async pattern:

- **Internal endpoint** accepts transcoding requests from content-api via secure HMAC auth
- **Webhook endpoint** receives completion callbacks from RunPod with HMAC verification
- **User endpoints** provide retry and status checking with session authentication
- **Database updates** are atomic to prevent race conditions
- **Error handling** is consistent with @codex/service-errors patterns
- **Security** is defense-in-depth: HMAC signatures, session auth, rate limiting, timing-safe verification

**Critical Success Factors**:
1. Understand RunPod's async nature (no polling, webhook-driven)
2. All R2/B2 paths must come from paths.ts
3. Database updates must be atomic with WHERE conditions
4. Webhook signature verification must be timing-safe
5. Creator scoping must be enforced on all user operations
